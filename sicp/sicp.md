sicp
====


A process is the entity in the machine, a program manipulates a process


primitive expressions - the smallest atomic unit of a program
means of combination - how to join primitive expressions
means of abstraction - naming cominations and manipulating them

operators are functions and can be returned as well as data


hash table is sorta of a table
global environment table
local environment table

learning - start with simple incomplete model and build up
use the simplest model that works

normal order vs applicative order evalu
lisps can switch between those two models,
application aka function/procedure method call.
eval and apply : apply in this case is the calling of primitive expressions

binary search in debugging


procedures are rules for manipulating data
manipulating the list of rules(procedure, method, function) as units
anonymous data anonymous procudures
naming data and procudures

master software engineers have confidence in their software that it will do what was written to do

figure out what the software should do(requirements) getting the software to meet the requirements





difference between computing and computer science

for background jobs, run multiple clones of the same job and then whichever completes first wins

computer science < computation

formulize a process

geometry = what is true, study of declarative knowledge

"computer science" = how to
"computer science" = study of imperative knowledge
"computer science/software engineering" = study of controlling complexity

The computer science complexty is different than other types of complexity because it is not real
not much difference between what I can imagine and what I can build

abstract form of engineering, ignore contraints imposed by reality

studying processes that solve problems

process: the worker, doer
procedure: pattern of rules, control the process

programming - first learning the rules and then the implications of those rules


software tests are declarative knowledge of an imperative system



techiques to control complexity
====
1) black box abstraction - suppress details
  a) primitive operations
  b) combination
  c) abstraction
2) convential interfaces - agreed upon ways to connect
3) metalingustic abstraction - make a new language - create a dsl



means of combination
forming trees
naming trees

combinations can be anonymous
abstraction is seperating and nameing - i guess abstraction can be anonymous

anonymous closures are a litmus test for a language


no difference in primitives and what is added by the programmer

procedures without params
  could be used for lazy eval
  when they have side effects
