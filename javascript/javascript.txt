# Javascript
prototype language

comma be  careful with commas

semicolons
if there is an error on the next lf character the compiler will insert a semicolon

new
create objects
pattern(guard) to detect when called by new

this
this breaks closureness
self pattern / bind pattern
You get to choose when something becomes a closure by using the self pattern
use bind instead of self pattern unless you need to access both different 'this' variables

functions
function declaration: line begins with function token
function expression: must wrap a function definition in () for it to be a function expression


undefined
two levels of undefined
1. never declared
2. declared but no undefined

var
var lets you be selective about what you closure over
var make local to function scope
in the global space it sets the dont delete flag

scope
scope is execution context only function scope
scopes are only created through functions

hoisting
hoisting is how variables are moved to the top of their containing scope
function definitions assignments are hoisted
function expressions are not hoisted. ( var foo = func() {} )

closure
A closure carries its scope with it, in a language where functions can be assigned to variables
Closures require the ability to inline function definitions: c cant do that
because it has to wrap its scopes, without inline func definitions it has no scope to wrap
A closure is a function wrapped up with its scoped
// Make a function that returns a closure function.
function myModule() {
  var name = "tim", age = 28;
  return function greet() {
    return "Hello " + name + ".  Wow, you are " + age + " years old.";
  }
}
// call `myModule` to get a closure out of it.
var greeter = myModule();
// Call the closure
greeter()



variables - labels references
  tentacles attached to a value

next statement
selection
loop

keywords

javascript always put ;


pass in functions
return functions

functions / methods help us avoid errors and reduce complexity

multiple arguments
multiple return values

pure functions - same result for same params

impure functions depend on context

global env / function environment

closure happens at definition / not call

variable shadow out environment

only functions create new context / environment / scope


Hoisting: look up all definitions(function and var) in the scope and define, then run
What is happening is that the computer looks up all function definitions, and stores the associated functions, before it starts executing the rest of the program. The same happens with functions that are defined inside other functions. When the outer function is called, the first thing that happens is that all inner functions are added to the new environment.


two ways to define functions
function nam() {}

foo = function


browsers
order of scripts defines order of fetch and execution
bottom of page prevents blocking while waiting for load


setinterval keeps executing

settimeout with recursive pattern, use with other async operations



javascript objects string keys


javascript === does not do type conversion

logical and shortcut like logical or


first token function it is a function statement

if an assignment is involved then is function expression like a math expression


self closure trick or bind to access outer this

function form this is set to global


no functions in loops, it closes over varialbes not current values
use either function factory or immediately invoked function
